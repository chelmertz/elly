// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package storage

import (
	"context"
)

const buriedPrs = `-- name: BuriedPrs :many
select url, last_updated from prs where buried = true
`

type BuriedPrsRow struct {
	Url         string
	LastUpdated string
}

func (q *Queries) BuriedPrs(ctx context.Context) ([]BuriedPrsRow, error) {
	rows, err := q.db.QueryContext(ctx, buriedPrs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BuriedPrsRow
	for rows.Next() {
		var i BuriedPrsRow
		if err := rows.Scan(&i.Url, &i.LastUpdated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bury = `-- name: Bury :exec
update prs set buried = true where url = ?
`

func (q *Queries) Bury(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, bury, url)
	return err
}

const clearActivePAT = `-- name: ClearActivePAT :exec
update pat set active = 0 where active = 1
`

func (q *Queries) ClearActivePAT(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearActivePAT)
	return err
}

const clearRateLimitUntil = `-- name: ClearRateLimitUntil :exec
delete from meta where key = 'rate_limit_until'
`

func (q *Queries) ClearRateLimitUntil(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearRateLimitUntil)
	return err
}

const createPr = `-- name: CreatePr :one
insert into prs (
    url,
    review_status,
    title,
    author,
    repo_name,
    repo_owner,
    repo_url,
    is_draft,
    last_updated,
    last_pr_commenter,
    threads_actionable,
    threads_waiting,
    additions,
    deletions,
    review_requested_from_users,
    buried,
    raw_json_response
) values (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) returning url, review_status, title, author, repo_name, repo_owner, repo_url, is_draft, last_updated, last_pr_commenter, threads_actionable, threads_waiting, additions, deletions, review_requested_from_users, buried, raw_json_response
`

type CreatePrParams struct {
	Url                      string
	ReviewStatus             string
	Title                    string
	Author                   string
	RepoName                 string
	RepoOwner                string
	RepoUrl                  string
	IsDraft                  bool
	LastUpdated              string
	LastPrCommenter          string
	ThreadsActionable        int64
	ThreadsWaiting           int64
	Additions                int64
	Deletions                int64
	ReviewRequestedFromUsers string
	Buried                   bool
	RawJsonResponse          []byte
}

func (q *Queries) CreatePr(ctx context.Context, arg CreatePrParams) (Pr, error) {
	row := q.db.QueryRowContext(ctx, createPr,
		arg.Url,
		arg.ReviewStatus,
		arg.Title,
		arg.Author,
		arg.RepoName,
		arg.RepoOwner,
		arg.RepoUrl,
		arg.IsDraft,
		arg.LastUpdated,
		arg.LastPrCommenter,
		arg.ThreadsActionable,
		arg.ThreadsWaiting,
		arg.Additions,
		arg.Deletions,
		arg.ReviewRequestedFromUsers,
		arg.Buried,
		arg.RawJsonResponse,
	)
	var i Pr
	err := row.Scan(
		&i.Url,
		&i.ReviewStatus,
		&i.Title,
		&i.Author,
		&i.RepoName,
		&i.RepoOwner,
		&i.RepoUrl,
		&i.IsDraft,
		&i.LastUpdated,
		&i.LastPrCommenter,
		&i.ThreadsActionable,
		&i.ThreadsWaiting,
		&i.Additions,
		&i.Deletions,
		&i.ReviewRequestedFromUsers,
		&i.Buried,
		&i.RawJsonResponse,
	)
	return i, err
}

const deactivateAllPATs = `-- name: DeactivateAllPATs :exec
update pat set active = 0 where active = 1
`

func (q *Queries) DeactivateAllPATs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deactivateAllPATs)
	return err
}

const deletePrs = `-- name: DeletePrs :exec
delete from prs
`

func (q *Queries) DeletePrs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deletePrs)
	return err
}

const getActivePAT = `-- name: GetActivePAT :one
select pat, set_at, expires_at, username from pat where active = 1 limit 1
`

type GetActivePATRow struct {
	Pat       string
	SetAt     string
	ExpiresAt string
	Username  string
}

func (q *Queries) GetActivePAT(ctx context.Context) (GetActivePATRow, error) {
	row := q.db.QueryRowContext(ctx, getActivePAT)
	var i GetActivePATRow
	err := row.Scan(
		&i.Pat,
		&i.SetAt,
		&i.ExpiresAt,
		&i.Username,
	)
	return i, err
}

const getLastFetched = `-- name: GetLastFetched :one
select value from meta where key = 'last_fetched' limit 1
`

func (q *Queries) GetLastFetched(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getLastFetched)
	var value string
	err := row.Scan(&value)
	return value, err
}

const getPr = `-- name: GetPr :one
select url, review_status, title, author, repo_name, repo_owner, repo_url, is_draft, last_updated, last_pr_commenter, threads_actionable, threads_waiting, additions, deletions, review_requested_from_users, buried, raw_json_response from prs where url = ? limit 1
`

func (q *Queries) GetPr(ctx context.Context, url string) (Pr, error) {
	row := q.db.QueryRowContext(ctx, getPr, url)
	var i Pr
	err := row.Scan(
		&i.Url,
		&i.ReviewStatus,
		&i.Title,
		&i.Author,
		&i.RepoName,
		&i.RepoOwner,
		&i.RepoUrl,
		&i.IsDraft,
		&i.LastUpdated,
		&i.LastPrCommenter,
		&i.ThreadsActionable,
		&i.ThreadsWaiting,
		&i.Additions,
		&i.Deletions,
		&i.ReviewRequestedFromUsers,
		&i.Buried,
		&i.RawJsonResponse,
	)
	return i, err
}

const getRateLimitUntil = `-- name: GetRateLimitUntil :one
select value from meta where key = 'rate_limit_until' limit 1
`

func (q *Queries) GetRateLimitUntil(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getRateLimitUntil)
	var value string
	err := row.Scan(&value)
	return value, err
}

const insertPAT = `-- name: InsertPAT :exec
insert into pat (pat, expires_at, username, active) values (?, ?, ?, 1)
`

type InsertPATParams struct {
	Pat       string
	ExpiresAt string
	Username  string
}

func (q *Queries) InsertPAT(ctx context.Context, arg InsertPATParams) error {
	_, err := q.db.ExecContext(ctx, insertPAT, arg.Pat, arg.ExpiresAt, arg.Username)
	return err
}

const listPrs = `-- name: ListPrs :many
select url, review_status, title, author, repo_name, repo_owner, repo_url, is_draft, last_updated, last_pr_commenter, threads_actionable, threads_waiting, additions, deletions, review_requested_from_users, buried, raw_json_response from prs
`

func (q *Queries) ListPrs(ctx context.Context) ([]Pr, error) {
	rows, err := q.db.QueryContext(ctx, listPrs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pr
	for rows.Next() {
		var i Pr
		if err := rows.Scan(
			&i.Url,
			&i.ReviewStatus,
			&i.Title,
			&i.Author,
			&i.RepoName,
			&i.RepoOwner,
			&i.RepoUrl,
			&i.IsDraft,
			&i.LastUpdated,
			&i.LastPrCommenter,
			&i.ThreadsActionable,
			&i.ThreadsWaiting,
			&i.Additions,
			&i.Deletions,
			&i.ReviewRequestedFromUsers,
			&i.Buried,
			&i.RawJsonResponse,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const storeLastFetched = `-- name: StoreLastFetched :exec
replace into meta (key, value) values ('last_fetched', ?)
`

func (q *Queries) StoreLastFetched(ctx context.Context, value string) error {
	_, err := q.db.ExecContext(ctx, storeLastFetched, value)
	return err
}

const storeRateLimitUntil = `-- name: StoreRateLimitUntil :exec
replace into meta (key, value) values ('rate_limit_until', ?)
`

func (q *Queries) StoreRateLimitUntil(ctx context.Context, value string) error {
	_, err := q.db.ExecContext(ctx, storeRateLimitUntil, value)
	return err
}

const unbury = `-- name: Unbury :exec
update prs set buried = false where url = ?
`

func (q *Queries) Unbury(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, unbury, url)
	return err
}
